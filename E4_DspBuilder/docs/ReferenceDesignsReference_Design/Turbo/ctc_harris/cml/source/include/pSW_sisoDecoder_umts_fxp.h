/* File pSW_sisoDecoder_umts_fxp.h
   
   Description: General functions used to implement parallel sliding window SISO decoding.
   				This is the fixed point version.   

*/

#ifndef INC_PSW_SISODECODER_UMTS_FXP_H
#define INC_PSW_SISODECODER_UMTS_FXP_H

#include <vector>
#include <fstream>

#if !defined(SC_INCLUDE_FX)
#define SC_INCLUDE_FX
#endif
#include "systemc.h"


//#include "ac_fixed.h"

#define DYNAMIC_BW			1
#define DATA_WIDTH_L		4 // Input data width left
#define DATA_WIDTH_R		2 // Input data width right
#define SOFT_WIDTH_L		7 // Soft value data width left
#define SOFT_WIDTH_R		2 // Soft value data width right

/* Class pSW_sisoDecoder_umts_fxp

  Description: Uses the (max)-log-MAP algorithm to perform soft-input, soft-output
  decoding of a convolutional code.

	Input parameters:
		out0[]		The output bits for each state if input is a 0 (generated by rsc_transit).
		state0[]	The next state if input is a 0 (generated by rsc_transit).
		out1[]		The output bits for each state if input is a 1 (generated by rsc_transit).
		state1[]	The next state if input is a 1 (generated by rsc_transit).
		input_c[]	The received signal in LLR-form. Must be in form r = 2*a*y/(sigma^2).
		input_u[]	The APP input.  This is the extrinsic output from the other decoder.
		KK			The constraint length of the convolutional code.
		nn      
		LL			The number of data bits.
		DecOpts		Decoder termination option = 0 for unterminated and = 1 for terminated.
		DecoderType	    = 0 Not used, will use 1 instead
						= 1 For max-log-MAP algorithm (i.e. max*(x,y) = max(x,y) )
						= 2 For Constant-log-MAP algorithm
						= 3 For log-MAP, correction factor using a LUT
						= 4 Reserved
						= 5 Scaling max-log-MAP
		num_engines     The number of parallel windows
		sldwin_size     Parallel window size
		iteration         current number of half iteration
		bit_width         bit width array for input and soft values
		bw_size           size of bit_width array
		
	Output parameters:
		output_c[]		The log-likelihood ratio of each data bit.
		output_u[]		The extrinsic information of each data bit.
  
*/

using namespace std;

#if DYNAMIC_BW

typedef sc_fix_fast data_fix_type;
typedef sc_fix_fast soft_fix_type;

#else

typedef sc_fixed_fast<DATA_WIDTH_L+DATA_WIDTH_R,DATA_WIDTH_L, SC_TRN, SC_SAT> data_fix_type;
typedef sc_fixed_fast<SOFT_WIDTH_L+SOFT_WIDTH_R,SOFT_WIDTH_L, SC_TRN, SC_SAT> soft_fix_type;

//typedef sc_fixed_fast<SOFT_WIDTH_L+SOFT_WIDTH_R,SOFT_WIDTH_L,SC_RND_INF,SC_SAT> soft_fix_type;
#endif


class pSW_sisoDecoder_umts_fxp
{
public:
	pSW_sisoDecoder_umts_fxp(vector<data_fix_type> *output_u,
				vector<data_fix_type> *output_c,
				vector<soft_fix_type> *output_b,
				vector<soft_fix_type> *output_llr,
				int    *out0, 
				int    *state0, 
				int    *out1, 
				int    *state1,
				vector<data_fix_type> &input_u,
				vector<data_fix_type> &input_c,
				int    KK,
				int    nn,
				int    LL,
				int	   DecoderType,
				int    num_engines,
				int    sldwin_size,
				vector<soft_fix_type> &alpha_beta_prev,
				int	   iteration,
				int	   *bit_width,
				int		bw_size);

	~pSW_sisoDecoder_umts_fxp();
	void do_work();

protected:
	soft_fix_type max_star(soft_fix_type,soft_fix_type);

	void initialize_alpha_at_iteration_0();
	void initialize_beta_at_iteration_0();

	void initialize_alpha();
	void initialize_beta(int window_id);
	void update_beta_at_the_tail();

	void update_branch_metric(int k,int p);
	void compute_block_beta(int k, int p, int s);
	void compute_alpha_and_llr(int window_id);
	void compute_block_alpha(int k, int p);

	void compute_beta(int window_id);
	void update_block_beta(int k,int p, int s);
	void update_alpha_prime(int p);
	void normalize_beta(int p, int s);
	void update_alpha_beta_prev_for_next_iteration(int window_id);

	void compute_llr(int k, int p, int s);
	void compute_output(int k, int p);
	void do_window(int window_id);

private:
	pSW_sisoDecoder_umts_fxp() {} // disbale the constructor
	soft_fix_type Gamma_fxp(int k,int symbol,int nn);
    void dump_alpha_beta_prev(int window_id);

protected:
	sc_fxtype_context *soft_fxtype_context;
	sc_fxtype_context *data_fxtype_context;

private:
	int		*out0, *state0, *out1, *state1;
	int		nn, frame_size;
	int		DecoderType;
	int		num_engines, sldwin_size;
	int		iteration;
	int		data_bwl, data_bwr, data_wl;
	int		soft_bwl, soft_bwr, soft_wl;
	int		num_windows, sub_frame_size, last_window_size;
	int		mm;			/* Memory of the RSC encoder. */
	int		max_states;	/* Number of states in the RSC encoder. */
	int		number_symbols; /* number of symbols */
	int     last_engine_frame_size;
	int		last_engine_last_window_size;
	int		last_engine_num_windows;

	data_fix_type	MIN_LOG, MAX_LOG;
	int		bw_diff;
	bool  overflow_flag;
	bool  quantization_flag;

	vector<int>		rev_out0, rev_state0, rev_out1, rev_state1;
	vector<data_fix_type>	*output_c_fxp_p,*output_u_fxp_p;
	vector<soft_fix_type>	*output_b_fxp_p, *output_llr_fxp_p;
	vector<soft_fix_type>	alpha_beta_prev_fxp;
	vector<data_fix_type>	input_c_fxp;
	vector<data_fix_type>	input_u_fxp;

	vector<vector<soft_fix_type> > metric_c;
	vector<vector<soft_fix_type> > beta;
	vector<vector<soft_fix_type> > alpha;
	vector<vector<soft_fix_type> > alpha_prime;
	vector<soft_fix_type> num_llr_u, den_llr_u;	/* Temporary variable used to compute LLR. */
	vector<vector<soft_fix_type> > num_llr_c, den_llr_c; /* Temp variable for LLR of code bits */
	vector<soft_fix_type> delta_num, delta_den;

	int window_id;

	ofstream fout_debug;  
};

#endif /* INC_PSW_SISODECODER_UMTS_FXP_H */
