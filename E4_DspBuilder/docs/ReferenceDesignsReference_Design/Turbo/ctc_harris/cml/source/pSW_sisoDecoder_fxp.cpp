/* File pSW_sisoDecoder_fxp.cpp

*/

#include "pSW_sisoDecoder_fxp.h"
#include "convolutional_fxp.h"
#include "maxstar_fxp.h"

/* Class pSW_sisoDecoder_fxp

  Description: Uses the (max)-log-MAP algorithm to perform soft-input, soft-output
  decoding of a convolutional code.

	Input parameters:
		out0[]		The output bits for each state if input is a 0 (generated by rsc_transit).
		state0[]	The next state if input is a 0 (generated by rsc_transit).
		out1[]		The output bits for each state if input is a 1 (generated by rsc_transit).
		state1[]	The next state if input is a 1 (generated by rsc_transit).
		input_c[]	The received signal in LLR-form. Must be in form r = 2*a*y/(sigma^2).
		input_u[]	The APP input.  This is the extrinsic output from the other decoder.
		KK			The constraint length of the convolutional code.
		nn      
		LL			The number of data bits.
		DecOpts		Decoder termination option = 0 for unterminated and = 1 for terminated.
		DecoderType	    = 0 Not used, will use 1 instead
						= 1 For max-log-MAP algorithm (i.e. max*(x,y) = max(x,y) )
						= 2 For Constant-log-MAP algorithm
						= 3 For log-MAP, correction factor using a LUT
						= 4 Reserved
						= 5 Scaling max-log-MAP
		num_subblocks     The number of parallel windows
		subblock_size     Parallel window size
		iteration         current number of half iteration
		bit_width         bit width array for input and soft values
		bw_size           size of bit_width array
		
	Output parameters:
		output_c[]		The log-likelihood ratio of each data bit. -- not calculated any more
		output_u[]		The extrinsic information of each data bit.
  
*/

pSW_sisoDecoder_fxp::pSW_sisoDecoder_fxp
(
	vector<data_fix_type> *output_u_p,
	vector<data_fix_type> *output_c_p,
	vector<soft_fix_type> *output_b_p,
	vector<soft_fix_type> *output_llr_p,
	int    *out0, 
	int    *state0, 
	int    *out1, 
	int    *state1,
	vector<data_fix_type> &input_u,
	vector<data_fix_type> &input_c,
	int    KK,
	int    nn,
	int    LL,
	int	   DecoderType,
	int    num_subblocks,
	int    subblock_size,
	vector<soft_fix_type> &alpha_beta_prev,
	int    iteration,
	int	   *bit_width,
	int		bw_size
)
: debug(false)
{
	this->out0            =  	out0;
	this->state0          =  	state0;
	this->out1            =  	out1;
	this->state1          =  	state1;
	this->nn              =  	nn ;
	this->frame_size      =  	LL ;
	this->DecoderType     =  	DecoderType;
	this->num_subblocks   =  	num_subblocks;
	this->subblock_size   =  	subblock_size;
	this->iteration		  =		iteration;

	/* derived constants */
	mm = KK-1;
	max_states = 1 << mm;			/* 2^mm */
	number_symbols = 1 << nn;	    /* 2^nn */

	rev_out0.resize(max_states);
	rev_state0.resize(max_states);
	rev_out1.resize(max_states);
	rev_state1.resize(max_states);
	delta_num.resize(max_states);
	delta_den.resize(max_states);

	for (int state = 0; state < max_states; state++)
	{
		rev_state0[state0[state]] = state;
		rev_state1[state1[state]] = state;
		rev_out0[state0[state]] = out0[state];
		rev_out1[state1[state]] = out1[state];
	}

	sub_frame_size = frame_size/num_subblocks;
	last_window_size = sub_frame_size%subblock_size;

	if (last_window_size == 0)
	{
		num_windows = sub_frame_size/subblock_size;
		last_window_size = subblock_size;
	}
	else
	{
		num_windows = sub_frame_size/subblock_size + 1;
	}


	this->output_u_fxp_p        =	output_u_p;
	this->output_b_fxp_p        =  	output_b_p;
	this->output_c_fxp_p        =  	output_c_p;
	this->output_llr_fxp_p      =  	output_llr_p;
	this->alpha_beta_prev_fxp =		alpha_beta_prev;
	this->input_u_fxp        =		input_u;
	this->input_c_fxp        =  	input_c;

	this->data_bwl = bit_width[0] - bit_width[1];
	this->data_bwr = bit_width[1];
	this->soft_bwl = bit_width[2] - bit_width[3];
	this->soft_bwr = bit_width[3];

	this->data_wl = data_bwl + data_bwr;
	this->soft_wl = soft_bwl + soft_bwr;

	bw_diff = soft_bwl - data_bwl;

	debug = false;
if(debug){
	overflow_flag = false;
	quantization_flag = false;
}

	MIN_LOG = -(1 << (data_bwl - 1));
    MAX_LOG[soft_wl-1] = 0;
	for (int i = 0; i < data_wl -1; i++)
	{
		MAX_LOG[i] = 1;
	}

	// Set the context for data and soft values
#if (DYNAMIC_BW)
	sc_fxtype_params param_soft(soft_bwl+soft_bwr, soft_bwl, SC_TRN, SC_WRAP);
	sc_fxtype_context cont_soft(param_soft);
#endif

	/* initialize internal arrays */
	metric_c.resize(num_subblocks);
	beta.resize(num_subblocks);
	alpha.resize(num_subblocks);
	alpha_prime.resize(num_subblocks);
	num_llr_c.resize(num_subblocks);
	den_llr_c.resize(num_subblocks);
	num_llr_u.resize(num_subblocks);
	den_llr_u.resize(num_subblocks);

	for (int i = 0; i < num_subblocks; i++)
	{
		metric_c[i].resize(number_symbols,0);
		beta[i].resize((subblock_size+1)*max_states,0);
		alpha[i].resize(max_states,0);
		alpha_prime[i].resize(max_states,0);
		num_llr_c[i].resize(nn,MIN_LOG);
		den_llr_c[i].resize(nn,MIN_LOG);
	}

if(debug){
//	if(iteration == 0)
		fout_debug.open("fout_debug_beta.txt");
}
}

pSW_sisoDecoder_fxp::~pSW_sisoDecoder_fxp()
{
	for (int i = 0; i < num_subblocks; i++)
	{
		metric_c[i].clear();
		beta[i].clear();
		alpha[i].clear();
		alpha_prime[i].clear();
		num_llr_c[i].clear();
		den_llr_c[i].clear();
	}

if(debug){
//	if(iteration == 0)
		fout_debug.close();
}
	rev_out0.clear();
	rev_state0.clear();
	rev_out1.clear();
	rev_state1.clear();
	delta_num.clear();
	delta_den.clear();

	metric_c.clear();
	beta.clear();
	alpha.clear();
	alpha_prime.clear();
	num_llr_c.clear();
	den_llr_c.clear();
	num_llr_u.clear();
	den_llr_u.clear();
}

soft_fix_type pSW_sisoDecoder_fxp::max_star
(
	soft_fix_type delta1,
	soft_fix_type delta2
)
{
	if (DecoderType == 3 || DecoderType == 2) // 3: LogMAP, 2: constant logMAP
	{
		soft_fix_type diff = delta2 > delta1 ? (delta2 - delta1) : (delta1 - delta2);

		// LUT
		// diff    0  0.25 0.5 0.75 1.00 1.25 1.50 1.75 2.0  >2.0
		// max* 0.75  0.50 0.5 0.50 0.25 0.25 0.25 0.25 0.25  0

		if (DecoderType == 3)
		{
			if (diff == 0)
			{
				delta1 += 0.75;
				delta2 += 0.75;
			}
			else if (diff <= 0.75)
			{
				delta1 += 0.5;
				delta2 += 0.5;
			}
			else if (diff <= 2.0)
			{
				delta1 += 0.25;
				delta2 += 0.25;
			}
		}
		else // DecoderType == 2
		{
			if (diff < 1.5)
			{
				delta1 += 0.5;
				delta2 += 0.5;
			}
		}
	}

	soft_fix_type result = delta2 > delta1 ? delta2 : delta1;

	return (result);
}

void pSW_sisoDecoder_fxp::update_block_beta(int k, int p,int s)
{
	soft_fix_type delta1, delta2;

    bool beta_monitor_on = false;

if(debug)
{
	beta_monitor_on = (iteration == 0 && p == 2 && k < frame_size);
	int temp;

	if (beta_monitor_on)
	{
		for (int i = 1; i < 4; i++)
		{
			temp = metric_c[p][i]*4;
			fout_debug << temp << " ";
		}

		for (int state = max_states-1; state > 0 ; state--)
		{
			temp = beta[p][(s+1)*max_states + state]*4;
			fout_debug << temp;
			if (state > 1) fout_debug << " ";
		}
		fout_debug << endl;
	}
}
//	soft_fix_type app_in = 0;
	
//	if (k < frame_size) app_in = input_u_fxp[k];

	/* step through all states */
	for (int state=0; state < max_states; state++ ) 
	{
		/* data 0 branch */
		delta1 = beta[p][(s+1)*max_states + state0[ state ]] + metric_c[p][ out0[ state ] ];

		/* data 1 branch */
		delta2 = beta[p][(s+1)*max_states + state1[ state ]] + metric_c[p][ out1[ state ] ];// + app_in;

		/* update beta */
		beta[p][s*max_states + state ] = max_star(delta1, delta2);
	}	
}

/* normalize alpha */
void pSW_sisoDecoder_fxp::update_alpha_prime(int p)
{
	int state;

	alpha_prime[p][0] = 0;
	for (state = 1; state < max_states; state++)
	{
		alpha_prime[p][state] = alpha[p][state] - alpha[p][0];
	}
}

/* normalize beta */
void pSW_sisoDecoder_fxp::normalize_beta(int p, int s)
{
	/* normalize beta */
	for (int state = 1; state < max_states; state++)
	{
		beta[p][s*max_states + state] -= beta[p][s*max_states];
	}

	beta[p][s*max_states] = 0;
}

void pSW_sisoDecoder_fxp::update_branch_metric(int k, int p)
{
	soft_fix_type app_in = 0;
	
	if (k < frame_size) app_in = input_u_fxp[k];

	/* precompute all possible branch metrics */
	metric_c[p][0] = 0;
	metric_c[p][1] = input_c_fxp[nn*k+1];
	metric_c[p][2] = input_c_fxp[nn*k] + app_in;
	metric_c[p][3] = input_c_fxp[nn*k]+input_c_fxp[nn*k+1] + app_in;
}

void pSW_sisoDecoder_fxp::compute_block_alpha(int k, int p)
{
	/* assign inputs */
//	soft_fix_type app_in = 0;
	
//	if (k < frame_size) app_in = input_u_fxp[k];

	soft_fix_type delta1, delta2;

	/* step through all states and find alpha */
	for (int state = 0; state < max_states; state++ ) {		
		/* Data 0 branch */
		delta1 = alpha_prime[p][ rev_state0[ state ] ] + metric_c[p][ rev_out0[ state ] ];

		/* Data 1 branch */
		delta2 = alpha_prime[p][ rev_state1[state]] + metric_c[p][ rev_out1[ state ] ]; // + app_in;

		alpha[p][ state ] = max_star(delta1, delta2);		
	}
}


void pSW_sisoDecoder_fxp::compute_llr(int k,int p, int s)
{
	int state;
	int symbol0, symbol1;	/* Symbols associated with data 0 and data 1 */
	soft_fix_type app_in = 0;

	soft_fix_type delta1, delta2;

	/* assign inputs */
//	if(k < frame_size)
//		app_in = input_u_fxp[k];

	/* compute the LLRs */	
	for (state=0;state<max_states;state++)  {
		symbol0 = out0[state];
		symbol1 = out1[state];
		
		/* data 0 branch (departing) */
		delta_den[state] = alpha_prime[p][state] + metric_c[p][ symbol0 ] + beta[p][(s+1)*max_states+state0[state]];

		/* data 1 branch (departing) */
		delta_num[state] = alpha_prime[p][state] + metric_c[p][ symbol1] + beta[p][(s+1)*max_states+state1[state]];// + app_in;
	}

	int num_states = max_states/2;

	while(num_states > 1)
	{
		for(int i = 0; i < num_states; i++)
		{
			delta_den[i] = max_star(delta_den[2*i],delta_den[2*i+1]);
			delta_num[i] = max_star(delta_num[2*i],delta_num[2*i+1]);
		}
		num_states /= 2;
	}

	/* den_llr and num_llr are used to compute the LLR and extrinsic info */
	den_llr_u[p] = max_star( delta_den[0], delta_den[1] );
	num_llr_u[p] = max_star( delta_num[0], delta_num[1] );
}

void pSW_sisoDecoder_fxp::compute_output(int k,int p)
{
	soft_fix_type temp;

	if (k < frame_size)
	{
		(*output_llr_fxp_p)[k] = num_llr_u[p] - den_llr_u[p];
		temp = (*output_llr_fxp_p)[k] - input_u_fxp[k];

		if (DecoderType == 5)
		{
			//temp *= 0.75;
			temp = (temp >> 1) + (temp >> 2);
		}

		if (temp > MAX_LOG)
		{
			(*output_u_fxp_p)[k] = MAX_LOG;
		}
		else if (temp < MIN_LOG)
		{
			(*output_u_fxp_p)[k] = MIN_LOG;
		}
		else
		{
			(*output_u_fxp_p)[k] = temp;
		}

	}

//	for (int i=0;i<nn;i++)
//	{
//		(*output_c_fxp_p)[nn*k+i] = num_llr_c[p][i] - den_llr_c[p][i];
//	}
}

void pSW_sisoDecoder_fxp::compute_block_beta(int k,int p,int s)
{
	/* precompute all possible branch metrics */
	update_branch_metric(k,p);

	/* update betas */
	update_block_beta(k,p,s);

	/* normalize beta */
	normalize_beta(p,s);
}

void pSW_sisoDecoder_fxp::update_beta_at_the_tail()
{
	for (int state = 0; state < max_states; state++)
	{
		beta[0][mm*max_states+state] = state == 0 ? (soft_fix_type)0 : MIN_LOG;
	}

	for (int k = frame_size + mm - 1; k >= frame_size; k--)
	{
		int s = k - frame_size;
		compute_block_beta(k,0,s);
	}

	int alpha_offset = num_subblocks*max_states;
	int offset = alpha_offset + (num_subblocks * num_windows - 1)*max_states;

	// save last beta
	for (int state=0; state < max_states; state++ )
	{
		alpha_beta_prev_fxp[offset + state] = beta[0][state];
	}
}

void pSW_sisoDecoder_fxp::update_alpha_beta_prev_for_next_iteration(int window_id)
{
	int p, offset, state;

	int alpha_offset = num_subblocks*max_states;
	
	for(p = 0; p < num_subblocks; p++)
	{
		if(window_id == num_windows - 1 && p < num_subblocks -1) // last window in a parallel processor (but not the last processor)
		{
			offset = (p+1)*max_states;

			// save alpha
			for (state = 0; state < max_states; state++)
			{
				alpha_beta_prev_fxp[offset+state] = alpha_prime[p][state];
			}
		}

		if(p > 0 || window_id > 0) // not the first window
		{
			offset = alpha_offset + (p * num_windows + window_id - 1)*max_states;

			// save beta
			for (state = 0; state < max_states; state++ )
			{
				alpha_beta_prev_fxp[offset + state] = beta[p][state];
			}
		}
	}

}

void pSW_sisoDecoder_fxp::compute_beta(int window_id)
{
	int s, k, p;

	int end = subblock_size;

	if (window_id == num_windows - 1)
	{
		end = last_window_size;
	}

	for(p = 0; p < num_subblocks; p++)
	{
		for (s = end - 1; s >= 0; s--)
		{
			k = p * sub_frame_size + window_id * subblock_size + s;
			compute_block_beta(k,p,s);
		}
	}
}

void pSW_sisoDecoder_fxp::compute_alpha_and_llr(int window_id)
{
	int s, k, p;
	int end = subblock_size;

	if (window_id == num_windows - 1)
	{
		end = last_window_size;
	}

	for(p = 0; p < num_subblocks; p++)
	{
		for (s = 0; s < end; s++)
		{
			k = p * sub_frame_size + window_id * subblock_size + s;

			/* precompute all possible branch metrics */
			update_branch_metric(k,p);

			compute_block_alpha(k,p);

			compute_llr(k,p,s);

			/* normalize and shift */
			update_alpha_prime(p);

			compute_output(k,p);
		}
	}
}

void pSW_sisoDecoder_fxp::initialize_alpha_at_iteration_0()
{
	for (int p = 0; p < num_subblocks; p++)
	{
		int offset = p * max_states;

		for (int state = 0; state < max_states; state++)
		{
			if (offset == 0) // Start of the trellis diagram
			{
				alpha_beta_prev_fxp[offset + state] = state == 0 ? (soft_fix_type)0 : MIN_LOG;
			}
			else
			{
				alpha_beta_prev_fxp[offset + state] = 0;
			}
		}
	}
}

void pSW_sisoDecoder_fxp::initialize_alpha()
{
	for (int p = 0; p < num_subblocks; p++)
	{
		int offset = p * max_states;

		for (int state = 0; state < max_states; state++)
		{
			alpha_prime[p][state] = alpha_beta_prev_fxp[offset + state];
		}
	}
}

void pSW_sisoDecoder_fxp::initialize_beta_at_iteration_0
(
)
{
	int alpha_offset = num_subblocks*max_states;
	int offset;

	for (int p = 0; p < num_subblocks; p++)
	{
		for (int window_id = 0; window_id < num_windows; window_id++)
		{
			offset = alpha_offset + (window_id + p * num_windows) * max_states;

			for (int state = 0; state < max_states; state++)
			{
				if (p == num_subblocks && window_id == num_windows - 1) // the end of the trellis diagram
				{
					// Initialize end beta
					alpha_beta_prev_fxp[offset + state] = (state == 0 ? (soft_fix_type)0 : MIN_LOG);
				}
				else
				{
					alpha_beta_prev_fxp[offset + state] = 0;
				}
			}
		}
	}
}

/* initialize beta */
void pSW_sisoDecoder_fxp::initialize_beta
(
	int window_id
)
{
	int alpha_offset = num_subblocks*max_states;
	int offset;

	int k, end;

	for (int p = 0; p < num_subblocks; p++)
	{
		offset = alpha_offset + (window_id + p * num_windows) * max_states;

		// the block size may be less than subblock_size for the last window
		if(window_id == num_windows - 1) 
		{
			end = last_window_size;
		}
		else
		{
			end = subblock_size;
		}

		for (int state = 0; state < max_states; state++)
		{
			beta[p][end*max_states + state] = alpha_beta_prev_fxp[offset + state];
		}
	}
}

void pSW_sisoDecoder_fxp::dump_alpha_beta_prev(int window_id)
{
	int p, state, s, k, start;

	for(p = 0; p < num_subblocks; p++)
	{
		fout_debug << "iteration = " << iteration << ", p = " << p << ", start = " << window_id * subblock_size + p * sub_frame_size << endl;
		for (state = 0; state < max_states; state++)
		{
			fout_debug << "alpha_prime[" << state << "]=" << alpha_prime[p][state] << " ";
		}
		fout_debug << endl;

		for (state = 0; state < max_states; state++)
		{
			fout_debug << "alpha[" << state << "]=" << alpha[p][state] << " ";
		}
		fout_debug << endl;

		for (s = 0; s < subblock_size; s++)
		{
			k = p * sub_frame_size + window_id * subblock_size + s;

			if (k > frame_size + mm)
				break;

			fout_debug << "k = " << k << ": ";
			for (state = 0; state < max_states; state++)
			{
				fout_debug << "beta[" << s*max_states + state << "]=" << beta[p][s*max_states + state] << " ";
			}
			fout_debug << endl;
		}
		fout_debug << endl;

		if (k > frame_size + mm + 1)
			break;

//		int window_id = start/subblock_size + p;
		int offset = window_id*max_states;
		for (state = 0; state < max_states; state++)
		{
			fout_debug << "i_alpha[" << offset+state << "]=" << alpha_beta_prev_fxp[offset+state] << " ";
		}
		fout_debug << endl;

		offset = (num_windows + window_id)*max_states;
		for (state = 0; state < max_states; state++)
		{
			fout_debug << "i_beta[" << offset+state << "]=" << alpha_beta_prev_fxp[offset+state] << " ";
		}
		fout_debug << endl;
	}
}

void pSW_sisoDecoder_fxp::do_window(int window_id)
{
	/* Initalize alpha only at teh first window */
	if (window_id == 0)
	{
		initialize_alpha();
	}

	initialize_beta(window_id);

	compute_beta(window_id);
	compute_alpha_and_llr(window_id);

	update_alpha_beta_prev_for_next_iteration(window_id);

if(debug){
	if(iteration == 2)
	{
//		fout_debug << "alpha_prime.wl= " << alpha_prime[0][0].wl() << endl;
//		fout_debug << "alpha.wl= " << alpha[0][0].wl() << endl;
//		fout_debug << "beta.wl= " << beta[0][0].wl() << endl;
//		fout_debug << "alpha_beta_prev_fxp.wl= " << alpha_beta_prev_fxp[0].wl() << endl;
//		dump_alpha_beta_prev(window_id);
	}
}

}

void pSW_sisoDecoder_fxp::do_work()
{
	if(iteration <= 1)
	{
		/* Initalization */
		initialize_alpha_at_iteration_0();
		initialize_beta_at_iteration_0();
		update_beta_at_the_tail();
	}
	
	for (int i = 0; i < num_windows; i++)
	{
		do_window(i);
	}


	// Update outputs for passing alpha and beta to next iteration
	for(int w = 0; w < (1 + num_windows) * num_subblocks; w++)
	{
		int offset = w*max_states;

		for (int state = 0; state < max_states; state++)
		{
			(*output_b_fxp_p)[offset+state] = alpha_beta_prev_fxp[offset+state];
		}
	}
}

